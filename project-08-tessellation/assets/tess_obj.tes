// -*- mode: glsl -*-
#version 410 core

layout(quads, equal_spacing, ccw) in;

in VertData {
  vec3 pos;
  vec2 uv;
} from_tcs[];

out vec2 uv;
out vec3 pos_v;
out vec3 light_dir_v;

vec3 interpolate3(vec3 v0, vec3 v1, vec3 v2, vec3 v3) {
  vec3 a = mix(v0, v1, gl_TessCoord.x);
  vec3 b = mix(v2, v3, gl_TessCoord.x);
  return mix(a, b, gl_TessCoord.y);
}

vec2 interpolate2(vec2 v0, vec2 v1, vec2 v2, vec2 v3) {
  vec2 a = mix(v0, v1, gl_TessCoord.x);
  vec2 b = mix(v2, v3, gl_TessCoord.x);
  return mix(a, b, gl_TessCoord.y);
}

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

// in world space
uniform vec3 light_dir_or_loc;
uniform int light_type;

uniform sampler2D displacement_map;
uniform sampler2D normal_map;

void main(void) {
  uv = interpolate2( from_tcs[0].uv,
                     from_tcs[1].uv,
                     from_tcs[2].uv,
                     from_tcs[3].uv );

  vec3 pos_m = interpolate3( from_tcs[0].pos,
                             from_tcs[1].pos,
                             from_tcs[2].pos,
                             from_tcs[3].pos );

  vec3 normal_m = normalize(texture(normal_map, uv).xyz);
  float disp = texture(displacement_map, uv).r;
  pos_m.z += disp * 0.5;

  vec4 pos_w = (model * vec4(pos_m, 1.0));
  gl_Position = projection * view * pos_w;

  pos_v = (view * pos_w).xyz;

  switch (light_type) {
  case 0: // directional light
    light_dir_v = normalize((view * vec4(light_dir_or_loc, 0.0)).xyz);
    break;
  case 1: // spot light
    vec3 dir_w = normalize(light_dir_or_loc - pos_w.xyz);
    light_dir_v = normalize((view * vec4(dir_w, 0.0)).xyz);
    break;
  }
}
